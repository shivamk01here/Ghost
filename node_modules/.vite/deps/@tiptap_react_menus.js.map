{
  "version": 3,
  "sources": ["../../@tiptap/react/src/menus/BubbleMenu.tsx", "../../@tiptap/react/src/menus/FloatingMenu.tsx"],
  "sourcesContent": ["import { type BubbleMenuPluginProps, BubbleMenuPlugin } from '@tiptap/extension-bubble-menu'\nimport { useCurrentEditor } from '@tiptap/react'\nimport React, { useEffect, useRef, useState } from 'react'\nimport { createPortal } from 'react-dom'\n\ntype Optional<T, K extends keyof T> = Pick<Partial<T>, K> & Omit<T, K>\n\nexport type BubbleMenuProps = Optional<Omit<Optional<BubbleMenuPluginProps, 'pluginKey'>, 'element'>, 'editor'> &\n  React.HTMLAttributes<HTMLDivElement>\n\nexport const BubbleMenu = React.forwardRef<HTMLDivElement, BubbleMenuProps>(\n  (\n    {\n      pluginKey = 'bubbleMenu',\n      editor,\n      updateDelay,\n      resizeDelay,\n      appendTo,\n      shouldShow = null,\n      getReferencedVirtualElement,\n      options,\n      children,\n      ...restProps\n    },\n    ref,\n  ) => {\n    const menuEl = useRef(document.createElement('div'))\n\n    if (typeof ref === 'function') {\n      ref(menuEl.current)\n    } else if (ref) {\n      ref.current = menuEl.current\n    }\n\n    const { editor: currentEditor } = useCurrentEditor()\n\n    /**\n     * The editor instance where the bubble menu plugin will be registered.\n     */\n    const pluginEditor = editor || currentEditor\n\n    // Creating a useMemo would be more computationally expensive than just\n    // re-creating this object on every render.\n    const bubbleMenuPluginProps: Omit<BubbleMenuPluginProps, 'editor' | 'element'> = {\n      updateDelay,\n      resizeDelay,\n      appendTo,\n      pluginKey,\n      shouldShow,\n      getReferencedVirtualElement,\n      options,\n    }\n    /**\n     * The props for the bubble menu plugin. They are accessed inside a ref to\n     * avoid running the useEffect hook and re-registering the plugin when the\n     * props change.\n     */\n    const bubbleMenuPluginPropsRef = useRef(bubbleMenuPluginProps)\n    bubbleMenuPluginPropsRef.current = bubbleMenuPluginProps\n\n    /**\n     * Track whether the plugin has been initialized, so we only send updates\n     * after the initial registration.\n     */\n    const [pluginInitialized, setPluginInitialized] = useState(false)\n\n    /**\n     * Track whether we need to skip the first options update dispatch.\n     * This prevents unnecessary updates right after plugin initialization.\n     */\n    const skipFirstUpdateRef = useRef(true)\n\n    useEffect(() => {\n      if (pluginEditor?.isDestroyed) {\n        return\n      }\n\n      if (!pluginEditor) {\n        console.warn('BubbleMenu component is not rendered inside of an editor component or does not have editor prop.')\n        return\n      }\n\n      const bubbleMenuElement = menuEl.current\n      bubbleMenuElement.style.visibility = 'hidden'\n      bubbleMenuElement.style.position = 'absolute'\n\n      const plugin = BubbleMenuPlugin({\n        ...bubbleMenuPluginPropsRef.current,\n        editor: pluginEditor,\n        element: bubbleMenuElement,\n      })\n\n      pluginEditor.registerPlugin(plugin)\n\n      const createdPluginKey = bubbleMenuPluginPropsRef.current.pluginKey\n\n      skipFirstUpdateRef.current = true\n      setPluginInitialized(true)\n\n      return () => {\n        setPluginInitialized(false)\n        pluginEditor.unregisterPlugin(createdPluginKey)\n        window.requestAnimationFrame(() => {\n          if (bubbleMenuElement.parentNode) {\n            bubbleMenuElement.parentNode.removeChild(bubbleMenuElement)\n          }\n        })\n      }\n    }, [pluginEditor])\n\n    /**\n     * Update the plugin options when props change after the plugin has been initialized.\n     * This allows dynamic updates to options like scrollTarget without re-registering the entire plugin.\n     */\n    useEffect(() => {\n      if (!pluginInitialized || !pluginEditor || pluginEditor.isDestroyed) {\n        return\n      }\n\n      // Skip the first update right after initialization since the plugin was just created with these options\n      if (skipFirstUpdateRef.current) {\n        skipFirstUpdateRef.current = false\n        return\n      }\n\n      pluginEditor.view.dispatch(\n        pluginEditor.state.tr.setMeta('bubbleMenu', {\n          type: 'updateOptions',\n          options: bubbleMenuPluginPropsRef.current,\n        }),\n      )\n    }, [\n      pluginInitialized,\n      pluginEditor,\n      updateDelay,\n      resizeDelay,\n      shouldShow,\n      options,\n      appendTo,\n      getReferencedVirtualElement,\n    ])\n\n    return createPortal(<div {...restProps}>{children}</div>, menuEl.current)\n  },\n)\n", "import type { FloatingMenuPluginProps } from '@tiptap/extension-floating-menu'\nimport { FloatingMenuPlugin } from '@tiptap/extension-floating-menu'\nimport { useCurrentEditor } from '@tiptap/react'\nimport React, { useEffect, useRef, useState } from 'react'\nimport { createPortal } from 'react-dom'\n\ntype Optional<T, K extends keyof T> = Pick<Partial<T>, K> & Omit<T, K>\n\nexport type FloatingMenuProps = Omit<Optional<FloatingMenuPluginProps, 'pluginKey'>, 'element' | 'editor'> & {\n  editor: FloatingMenuPluginProps['editor'] | null\n  options?: FloatingMenuPluginProps['options']\n} & React.HTMLAttributes<HTMLDivElement>\n\nexport const FloatingMenu = React.forwardRef<HTMLDivElement, FloatingMenuProps>(\n  (\n    {\n      pluginKey = 'floatingMenu',\n      editor,\n      updateDelay,\n      resizeDelay,\n      appendTo,\n      shouldShow = null,\n      options,\n      children,\n      ...restProps\n    },\n    ref,\n  ) => {\n    const menuEl = useRef(document.createElement('div'))\n\n    if (typeof ref === 'function') {\n      ref(menuEl.current)\n    } else if (ref) {\n      ref.current = menuEl.current\n    }\n\n    const { editor: currentEditor } = useCurrentEditor()\n\n    /**\n     * The editor instance where the floating menu plugin will be registered.\n     */\n    const pluginEditor = editor || currentEditor\n\n    // Creating a useMemo would be more computationally expensive than just\n    // re-creating this object on every render.\n    const floatingMenuPluginProps: Omit<FloatingMenuPluginProps, 'editor' | 'element'> = {\n      updateDelay,\n      resizeDelay,\n      appendTo,\n      pluginKey,\n      shouldShow,\n      options,\n    }\n\n    /**\n     * The props for the floating menu plugin. They are accessed inside a ref to\n     * avoid running the useEffect hook and re-registering the plugin when the\n     * props change.\n     */\n    const floatingMenuPluginPropsRef = useRef(floatingMenuPluginProps)\n    floatingMenuPluginPropsRef.current = floatingMenuPluginProps\n\n    /**\n     * Track whether the plugin has been initialized, so we only send updates\n     * after the initial registration.\n     */\n    const [pluginInitialized, setPluginInitialized] = useState(false)\n\n    /**\n     * Track whether we need to skip the first options update dispatch.\n     * This prevents unnecessary updates right after plugin initialization.\n     */\n    const skipFirstUpdateRef = useRef(true)\n\n    useEffect(() => {\n      if (pluginEditor?.isDestroyed) {\n        return\n      }\n\n      if (!pluginEditor) {\n        console.warn(\n          'FloatingMenu component is not rendered inside of an editor component or does not have editor prop.',\n        )\n        return\n      }\n\n      const floatingMenuElement = menuEl.current\n      floatingMenuElement.style.visibility = 'hidden'\n      floatingMenuElement.style.position = 'absolute'\n\n      const plugin = FloatingMenuPlugin({\n        ...floatingMenuPluginPropsRef.current,\n        editor: pluginEditor,\n        element: floatingMenuElement,\n      })\n\n      pluginEditor.registerPlugin(plugin)\n\n      const createdPluginKey = floatingMenuPluginPropsRef.current.pluginKey\n\n      skipFirstUpdateRef.current = true\n      setPluginInitialized(true)\n\n      return () => {\n        setPluginInitialized(false)\n        pluginEditor.unregisterPlugin(createdPluginKey)\n        window.requestAnimationFrame(() => {\n          if (floatingMenuElement.parentNode) {\n            floatingMenuElement.parentNode.removeChild(floatingMenuElement)\n          }\n        })\n      }\n    }, [pluginEditor])\n\n    /**\n     * Update the plugin options when props change after the plugin has been initialized.\n     * This allows dynamic updates to options like scrollTarget without re-registering the entire plugin.\n     */\n    useEffect(() => {\n      if (!pluginInitialized || !pluginEditor || pluginEditor.isDestroyed) {\n        return\n      }\n\n      // Skip the first update right after initialization since the plugin was just created with these options\n      if (skipFirstUpdateRef.current) {\n        skipFirstUpdateRef.current = false\n        return\n      }\n\n      pluginEditor.view.dispatch(\n        pluginEditor.state.tr.setMeta('floatingMenu', {\n          type: 'updateOptions',\n          options: floatingMenuPluginPropsRef.current,\n        }),\n      )\n    }, [pluginInitialized, pluginEditor, updateDelay, resizeDelay, shouldShow, options, appendTo])\n\n    return createPortal(<div {...restProps}>{children}</div>, menuEl.current)\n  },\n)\n"],
  "mappings": "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",
  "names": ["import_react", "import_react", "import_react_dom", "import_jsx_runtime", "React", "useRef", "useCurrentEditor", "useState", "useEffect", "createPortal", "jsx"]
}
